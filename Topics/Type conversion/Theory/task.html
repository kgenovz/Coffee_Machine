<h2>Type conversion</h2>
<div class="step-text">
<p>Type conversion, or type casting, involves switching a value from one <a class="theory-lookup" href="/learn/step/4388" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, data types are a fundamental aspect of the language's type system, which includes various basic types that serve as building blocks for data manipulation. | Data types represent different kinds of data that can be stored and manipulated within a program. For instance, the `Int` data type represents a 32-bit signed integer, which can range from a minimum value of -2^31 to a maximum value of 2^31-1.">data type</a> to another. This is notably critical in Kotlin because it is a statically typed language, which signifies that types are identified and strictly applied at <a class="theory-lookup" href="/learn/step/11559" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, the compilation process involves converting the high-level Kotlin code into low-level bytecode that can be executed on the Java Virtual Machine (JVM). | This is achieved through a two-step process:

1. **Kotlin Compiler**: The Kotlin compiler takes the Kotlin source code and converts it into Java bytecode. This bytecode can then be executed on the JVM.">compile</a> time.</p> <h5 id="implicit-conversion">Implicit Conversion</h5><p>Kotlin does not permit <a class="theory-lookup" href="/learn/step/9506" rel="noopener noreferrer nofollow" target="_blank" title="It is a statically typed language, which means that type are identified and strictly applied at compile time. | Kotlin does not allow implicit conversion to avoid precision loss or unforeseen outcomes. For instance, an Integer cannot automatically convert to a Double. When you need to switch a variable from one type to another in Kotlin, explicit type conversion is necessary. Kotlin provides several methods for explicit type conversion, such as using the 'as' keyword or the 'toString()' function.">implicit conversions</a> to avoid precision loss or unforeseen outcomes. For instance, a <code class="language-kotlin">Long</code> cannot automatically convert to an <code class="language-kotlin">Int</code>.</p><pre><code class="language-kotlin">val longValue: Long = 100L
// val intValue: Int = longValue // Error: Type mismatch
</code></pre> <h5 id="explicit-type-conversion-type-casts-in-kotlin">Explicit Type Conversion (Type Casts) in Kotlin</h5><p>When you need to switch a <a class="theory-lookup" href="/learn/step/4371" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a variable is a storage for a value, which can be a string, a number, or something else. | Every variable has a name (or an identifier) to distinguish it from other variables. You can access a value by the name of the variable. Variables are one of the most often used elements in programming, so it is important to understand how to use them. Before you can start using a variable, you must declare it. To declare a variable, Kotlin provides two keywords: `val` and `var`.">variable</a> from <a class="theory-lookup" href="/learn/step/13264" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, one type is a unique type that doesn't have an instance. | It is used when a function never returns a value, not even the Unit type. The Nothing type is a subtype of every known type in Kotlin, meaning it can be used in place of any other type. It serves as a signal or marker to indicate that a function or expression will never return a value, which can be useful in certain situations, such as handling exceptions or signaling failure.">one type</a> to another in Kotlin, <a class="theory-lookup" href="/learn/step/9506" rel="noopener noreferrer nofollow" target="_blank" title="Explicit type conversion, also known as type casting, in Kotlin is the process of converting a value from one data type to another. | This is necessary because Kotlin is a statically typed language, which means that type are identified and strictly applied at compile time. Unlike some other languages, Kotlin does not permit implicit conversion to avoid precision loss or unforeseen outcomes. Instead, explicit type conversion must be used when switching a variable from one type to another.">explicit type conversion</a> is necessary. Kotlin is a statically-typed language, meaning types are checked at compile time and implicit type conversion is not permitted. Below are some <a class="theory-lookup" href="/learn/step/27975" rel="noopener noreferrer nofollow" target="_blank" title="A method in Kotlin is a block of code that is executed when it is called. | It is similar to a function in that it performs a specific task, but it is associated with an object or class. Methods can take parameters, perform operations on those parameters, and return values. They can also be overridden in subclasses to provide different behavior. By default, methods in Kotlin are final and cannot be overridden, but using the open keyword makes them overridable.">methods</a> that Kotlin provides for explicit type conversion:</p><ul><li><p><code class="language-kotlin">toInt()</code>: Use this when you need to transform the value into an <code class="language-kotlin">Int</code>, or an integer format of a value.</p><pre><code class="language-kotlin">val doubleValue = 2.5
val intValue = doubleValue.toInt() // intValue will be 2</code></pre></li><li><p><code class="language-kotlin">toFloat()</code>: Converts the value to a floating-point representation, or <code class="language-kotlin">Float</code>.</p><pre><code class="language-kotlin">val intValue = 10
val floatValue = intValue.toFloat() // floatValue will be 10.0</code></pre></li><li><p><code class="language-kotlin">toLong()</code>: Use this when working with larger <a class="theory-lookup" href="/learn/step/4488" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, an integer is a type of number without a decimal point. | It can be represented by the types Int (32-bit) or Long (64-bit). You can perform arithmetic operations such as addition, subtraction, multiplication, division, and modulus with integer variables. To declare a variable of the type Int, you can use one of the following ways: by assigning a value within the range of Int, by specifying the type after the variable name, or by tagging the value with the suffix 'L'.">integer</a> values; it transforms the value into a <code class="language-kotlin">Long</code>.</p><pre><code class="language-kotlin">val intValue = 100
val longValue = intValue.toLong() // longValue will be 100L</code></pre></li><li><p><code class="language-kotlin">toDouble()</code>: Use this when dealing with high-precision arithmetic, it transforms the value into a <code class="language-kotlin">Double</code>.</p><pre><code class="language-kotlin">val floatValue = 10.5f
val doubleValue = floatValue.toDouble() // doubleValue will be 10.5</code></pre></li><li><p><code class="language-kotlin">toByte()</code>: Transforms the value into a <code class="language-kotlin">Byte</code>; it's often used when dealing with low-level byte manipulation.</p><pre><code class="language-kotlin">val intValue = 1
val byteValue = intValue.toByte() // byteValue will be 1</code></pre></li><li><p><code class="language-kotlin">toShort()</code>: Transforms the value into a <code class="language-kotlin">Short</code>. This method is lesser-known but can be helpful for specific scenarios.</p><pre><code class="language-kotlin">val intValue = 5
val shortValue = intValue.toShort() // shortValue will be 5</code></pre></li><li><p><code class="language-kotlin">toString()</code>: This is often used for <a class="theory-lookup" href="/learn/step/19751" rel="noopener noreferrer nofollow" target="_blank" title="Conversion in Kotlin refers to the process of switching a value from one data type to another. | This is critical in Kotlin because it is a statically typed language, meaning type are identified and strictly applied at compile time. Kotlin does not permit implicit conversion to avoid precision loss or unforeseen outcomes. When you need to switch a variable from one type to another in Kotlin, explicit type conversion is necessary. Kotlin provides several methods for explicit type conversion, such as using the 'to' keyword or the 'as' keyword.">converting</a> the value into a text representation, <code class="language-kotlin">String</code>, or for <a class="theory-lookup" href="/learn/step/12553" rel="noopener noreferrer nofollow" target="_blank" title="Concatenation in Kotlin refers to the process of combining two or more strings into a single string. | This is a common operation when working with strings and is often used to build larger strings from smaller ones. The concatenation operator in Kotlin is the + symbol, which can be used to combine any two strings. When concatenating strings, the order of the strings matters, as the resulting string will be in the same order as the strings being combined.">concatenation</a>.</p><pre><code class="language-kotlin">val intValue = 10
val stringValue = intValue.toString() // stringValue will be "10"</code></pre></li></ul><p>Any of these methods can be invoked on a variable to convert it to the desired type. Keep in mind that, if the value being transformed is beyond the range of the target type, data loss or truncation may result. Make sure the value can safely change to prevent unexpected behavior.</p> <h5 id="type-conversion-best-practices-in-kotlin">Type Conversion Best Practices in Kotlin</h5><p>You must execute type conversion with caution in Kotlin to avoid problems like precision loss or <code class="language-kotlin">ClassCastException</code>. Here are some guidelines to remember:</p><ol><li><p><strong>Use Explicit Conversions</strong>: Kotlin doesn't permit implicit type conversion, so utilize explicit methods like <code class="language-kotlin">toInt()</code>, <code class="language-kotlin">toDouble()</code>, and so on.</p><pre><code class="language-kotlin">val i: Int = "123".toInt()</code></pre></li><li><p><strong>Check for null</strong>: If you are working with <a class="theory-lookup" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="A nullable type in Kotlin is a variable declaration that can hold a value or be null. | When working with nullable types, Kotlin requires developers to handle the possibility of null values explicitly, making the code safer and more predictable. This is achieved by offering tools such as safe calls, the elvis operator, and non-null assertions, which help developers avoid null reference errors and create more stable and maintainable code. By introducing a clear distinction between nullable and non-nullable types, Kotlin aims to eliminate the dreaded null reference exceptions from our code.">nullable types</a>, make sure to use the safe call operator <code class="language-kotlin">?.</code> before conversion.</p><pre><code class="language-kotlin">val s: String? = null
val i: Int? = s?.toInt()</code></pre></li><li><p><strong>Handle </strong><code class="language-kotlin">NumberFormatException</code>: Potential <code class="language-kotlin">NumberFormatException</code> should be handled when converting from <code class="language-kotlin">String</code> to a numeric type.</p><pre><code class="language-kotlin">val s: String = "abc"
val i: Int? = try { s.toInt() } catch (e: NumberFormatException) { null }</code></pre></li><li><p><strong>Avoid Loss of Precision</strong>: Be careful when converting between numeric types to avoid losing precision.</p><pre><code class="language-kotlin">val l: Long = 1_000_000_000L
val i: Int = l.toInt() // Potential loss of precision</code></pre></li><li><p><strong>Smart Casts with </strong><code class="language-kotlin">is</code>: Use <code class="language-kotlin">is</code> checks for safe casting when dealing with inheritance.</p><pre><code class="language-kotlin">if (obj is String) {
    println(obj.length)
}</code></pre></li><li><p><strong>Use the </strong><code class="language-kotlin">as?</code> Operator for Safe Casting: Use <code class="language-kotlin">as?</code> to safely cast to a type and to avoid <code class="language-kotlin">ClassCastException</code>. This will <a class="theory-lookup" href="/learn/step/39052" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, the 'return' keyword is used to exit a function and optionally return a value. | When a function returns, it implies that the function is invoked for its side effect, such as printing to the console, rather than for the result it returns. If a function does not return any valuable value, Kotlin provides the Unit type, which is comparable to void in languages like Java or C++. It's unnecessary to specify a return type in this case because it's the default return type if none is declared.">return</a> <code class="language-kotlin">null</code> if the operation fails.</p><pre><code class="language-kotlin">val x: Any = "Kotlin"
val s: String? = x as? String</code></pre></li></ol><p>By following these practices, you can ensure that your data remains intact and prevents runtime <a class="theory-lookup" href="/learn/step/7601" rel="noopener noreferrer nofollow" target="_blank" title="An exception in Kotlin is an event that disrupts the normal flow of a program when it encounters an error, such as attempting to access an index that does not exist in an array. | Kotlin uses exceptions to manage these unexpected problems, where exception objects contain information about the error. The standard method for triggering an exception is by using the keyword 'throw' followed by an instance of the exception. Kotlin has a 'try' block to handle exceptions, containing the code that might trigger an exception, while the 'catch' block is used to spot and manage the exception.">exceptions</a> during type conversions in Kotlin.</p> <h5 id="conclusion">Conclusion</h5><p>Because of Kotlin's statically typed nature, type conversion is a fundamental concept that demands explicit handling of data type changes. Kotlin does not allow implicit conversions, thereby ensuring <a class="theory-lookup" href="/learn/step/7619" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, type safety is a feature of the language's static type system that ensures the type of a variable is known at compile time, preventing type-related errors and optimizing performance. | This means that the compiler checks the types of variables and expressions during the compilation phase, detecting any potential errors before the program runs. Additionally, Kotlin's type system is designed to eliminate common issues such as null pointer exceptions, providing a more robust and expressive syntax for modern application development.">type safety</a> and preventing undesirable outcomes. Instead, <a class="theory-lookup" href="/learn/step/9506" rel="noopener noreferrer nofollow" target="_blank" title="Explicit conversion, also known as type casting, is the process of switching a value from one data type to another in Kotlin. | This is crucial because Kotlin is a statically typed language, meaning that types are identified and strictly applied at compile time. Unlike some other languages, Kotlin does not permit implicit conversion to avoid precision loss or unforeseen outcomes. For example, an integer cannot automatically convert to a floating-point number. When you need to switch a variable from one type to another in Kotlin, explicit type conversion is necessary.">explicit conversions</a> using methods like <code class="language-kotlin">toInt()</code>, <code class="language-kotlin">toFloat()</code>, and others are necessary when dealing with various numeric types.</p>
</div>
